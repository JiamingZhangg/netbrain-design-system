"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
const TYPE = '%TYPE';
const VERSION = '%VERSION';
const defaultOptions = {
    label: 'released',
    lockIssues: false,
    message: `:rocket: ${TYPE} was released in ${VERSION} :rocket:`
};
const closeIssue = /(?:Close|Closes|Closed|Fix|Fixes|Fixed|Resolve|Resolves|Resolved)\s((?:#\d+(?:,\s)?)+)/gi;
const isCanary = (version) => version.match('canary');
class ReleasedLabelPlugin {
    constructor(options = {}) {
        this.name = 'Released Label';
        this.options = deepmerge_1.default(defaultOptions, options);
    }
    apply(auto) {
        auto.hooks.modifyConfig.tap(this.name, config => {
            config.labels.released = config.labels.released || {
                name: 'released',
                description: 'This issue/pull request has been released.'
            };
            return config;
        });
        auto.hooks.onCreateLogParse.tap(this.name, logParse => {
            logParse.hooks.omitCommit.tapPromise(this.name, async (commit) => {
                if (commit.labels.includes(this.options.label)) {
                    return true;
                }
            });
        });
        auto.hooks.afterRelease.tapPromise(this.name, async ({ newVersion, commits }) => {
            if (!newVersion) {
                return;
            }
            if ('dryRun' in auto.options && auto.options.dryRun) {
                return;
            }
            const head = commits[0];
            if (!head) {
                return;
            }
            const isSkipped = head.labels.find(label => auto.release.options.skipReleaseLabels.includes(label));
            if (isSkipped) {
                return;
            }
            await Promise.all(commits.map(async (commit) => this.addReleased(auto, commit, newVersion)));
        });
    }
    async addReleased(auto, commit, newVersion) {
        const messages = [commit.subject];
        if (commit.pullRequest) {
            await this.addCommentAndLabel(auto, newVersion, commit.pullRequest.number);
            const pr = await auto.git.getPullRequest(commit.pullRequest.number);
            pr.data.body.split('\n').map(line => messages.push(line));
            const commitsInPr = await auto.git.getCommitsForPR(commit.pullRequest.number);
            commitsInPr.map(c => messages.push(c.commit.message));
        }
        const issues = messages
            .map(message => message.match(closeIssue))
            .filter((r) => Boolean(r))
            .reduce((all, arr) => [...all, ...arr], [])
            .map(issue => issue.match(/#(\d+)/i))
            .filter((r) => Boolean(r))
            .map(match => Number(match[1]));
        await Promise.all(issues.map(async (issue) => {
            await this.addCommentAndLabel(auto, newVersion, issue, true);
            if (this.options.lockIssues && !isCanary(newVersion)) {
                await auto.git.lockIssue(issue);
            }
        }));
    }
    async addCommentAndLabel(auto, newVersion, prOrIssue, isIssue = false) {
        // leave a comment with the new version
        const message = this.createReleasedComment(isIssue, newVersion);
        await auto.comment({ message, pr: prOrIssue, context: 'released' });
        // Do not add released to issue/label for canary versions
        if (isCanary(newVersion)) {
            return;
        }
        // add a `released` label to a PR
        const labels = await auto.git.getLabels(prOrIssue);
        if (!labels.includes(this.options.label)) {
            await auto.git.addLabelToPr(prOrIssue, this.options.label);
        }
    }
    createReleasedComment(isIssue, version) {
        return this.options.message
            .replace(new RegExp(TYPE, 'g'), isIssue ? 'Issue' : 'PR')
            .replace(new RegExp(VERSION, 'g'), version);
    }
}
exports.default = ReleasedLabelPlugin;
//# sourceMappingURL=index.js.map