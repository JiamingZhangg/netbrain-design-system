"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const env_ci_1 = tslib_1.__importDefault(require("env-ci"));
const fs = tslib_1.__importStar(require("fs"));
const parse_author_1 = tslib_1.__importDefault(require("parse-author"));
const path_1 = tslib_1.__importDefault(require("path"));
const typescript_memoize_1 = require("typescript-memoize");
const core_1 = require("@auto-it/core");
const get_monorepo_packages_1 = tslib_1.__importDefault(require("get-monorepo-packages"));
const semver_1 = require("semver");
const package_config_1 = tslib_1.__importDefault(require("./package-config"));
const set_npm_token_1 = tslib_1.__importDefault(require("./set-npm-token"));
const utils_1 = require("./utils");
const { isCi } = env_ci_1.default();
function isMonorepo() {
    return fs.existsSync('lerna.json');
}
async function getPublishedVersion(name) {
    try {
        return await core_1.execPromise('npm', ['view', name, 'version']);
    }
    catch (error) { }
}
async function greaterRelease(prefixRelease, name, packageVersion) {
    const publishedVersion = await getPublishedVersion(name);
    if (!publishedVersion) {
        return packageVersion;
    }
    const publishedPrefixed = prefixRelease(publishedVersion);
    return semver_1.gt(packageVersion, publishedPrefixed)
        ? packageVersion
        : publishedPrefixed;
}
exports.greaterRelease = greaterRelease;
const inFolder = (parent, child) => {
    const relative = path_1.default.relative(parent, child);
    return Boolean(relative && !relative.startsWith('..') && !path_1.default.isAbsolute(relative));
};
async function changedPackages({ sha, packages, lernaJson, logger, version }) {
    const changed = new Set();
    const changedFiles = await core_1.execPromise('git', [
        'show',
        '--first-parent',
        sha,
        '--name-only',
        '--pretty='
    ]);
    changedFiles.split('\n').forEach(filePath => {
        const monorepoPackage = packages.find(subPackage => inFolder(subPackage.path, filePath));
        if (!monorepoPackage) {
            return;
        }
        changed.add(lernaJson.version === 'independent'
            ? `${monorepoPackage.name}@${semver_1.inc(monorepoPackage.version, version)}`
            : monorepoPackage.name);
    });
    if (changed.size > 0) {
        logger.veryVerbose.info(`Got changed packages for ${sha}:\n`, changed);
    }
    return [...changed];
}
exports.changedPackages = changedPackages;
function getMonorepoPackage() {
    const packages = get_monorepo_packages_1.default(process.cwd());
    return packages.reduce((greatest, subPackage) => {
        if (subPackage.package.version) {
            if (!greatest.version) {
                return subPackage.package;
            }
            return semver_1.gt(greatest.version, subPackage.package.version)
                ? greatest
                : subPackage.package;
        }
        return greatest;
    }, {});
}
exports.getMonorepoPackage = getMonorepoPackage;
async function bumpLatest({ version: localVersion, name }, version) {
    const latestVersion = localVersion
        ? await greaterRelease(s => s, name, localVersion)
        : undefined;
    return latestVersion ? semver_1.inc(latestVersion, version) : version;
}
const verbose = ['--loglevel', 'silly'];
const getLernaJson = () => JSON.parse(fs.readFileSync('lerna.json', 'utf8'));
const checkClean = async (auto) => {
    const status = await core_1.execPromise('git', ['status', '--porcelain']);
    if (!status) {
        return;
    }
    auto.logger.log.error('Changed Files:\n', status);
    throw new Error('Working direction is not clean, make sure all files are commited');
};
class NPMPlugin {
    constructor(config = {}) {
        this.name = 'NPM';
        this.setRcToken =
            typeof config.setRcToken === 'boolean' ? config.setRcToken : true;
        this.forcePublish =
            typeof config.forcePublish === 'boolean' ? config.forcePublish : true;
    }
    async getLernaPackages() {
        return core_1.execPromise('npx', ['lerna', 'ls', '-pl']).then(res => res.split('\n').map(packageInfo => {
            const [packagePath, name, version] = packageInfo.split(':');
            return { path: packagePath, name, version };
        }));
    }
    async getIndependentPackageList() {
        return this.getLernaPackages().then(packages => packages
            .map(p => `\n - \`${p.name}@${p.version.split('+')[0]}\``)
            .join(''));
    }
    apply(auto) {
        const isVerbose = auto.logger.logLevel === 'verbose' ||
            auto.logger.logLevel === 'veryVerbose';
        const verboseArgs = isVerbose ? verbose : [];
        auto.hooks.beforeShipIt.tap(this.name, async () => {
            if (!isCi) {
                return;
            }
            auto.checkEnv(this.name, 'NPM_TOKEN');
        });
        auto.hooks.getAuthor.tapPromise(this.name, async () => {
            auto.logger.verbose.info('NPM: Getting repo information from package.json');
            const packageJson = await utils_1.loadPackageJson();
            if (!packageJson.author) {
                return;
            }
            const { author } = packageJson;
            if (typeof author === 'string') {
                return parse_author_1.default(author);
            }
            return author;
        });
        auto.hooks.getPreviousVersion.tapPromise(this.name, async (prefixRelease) => {
            let previousVersion = '';
            if (isMonorepo()) {
                auto.logger.veryVerbose.info('Using monorepo to calculate previous release');
                const monorepoVersion = JSON.parse(await utils_1.readFile('lerna.json', 'utf-8')).version;
                if (monorepoVersion === 'independent') {
                    previousVersion =
                        'dryRun' in auto.options && auto.options.dryRun
                            ? await this.getIndependentPackageList()
                            : '';
                }
                else {
                    const releasedPackage = getMonorepoPackage();
                    if (!releasedPackage.name && !releasedPackage.version) {
                        previousVersion = prefixRelease(monorepoVersion);
                    }
                    else {
                        previousVersion = await greaterRelease(prefixRelease, releasedPackage.name, prefixRelease(monorepoVersion));
                    }
                }
            }
            else if (fs.existsSync('package.json')) {
                auto.logger.veryVerbose.info('Using package.json to calculate previous version');
                const { version, name } = await utils_1.loadPackageJson();
                previousVersion = version
                    ? await greaterRelease(prefixRelease, name, prefixRelease(version))
                    : '0.0.0';
            }
            auto.logger.verbose.info('NPM: Got previous version from package.json', previousVersion);
            return previousVersion;
        });
        auto.hooks.getRepository.tapPromise(this.name, async () => {
            auto.logger.verbose.info('NPM: getting repo information from package.json');
            return package_config_1.default();
        });
        auto.hooks.onCreateRelease.tap(this.name, release => {
            release.hooks.createChangelogTitle.tap(`${this.name} - lerna independent`, () => {
                if (isMonorepo() && getLernaJson().version === 'independent') {
                    return '';
                }
            });
        });
        auto.hooks.onCreateChangelog.tap(this.name, (changelog, version) => {
            changelog.hooks.renderChangelogLine.tapPromise('NPM - Monorepo', async ([commit, line]) => {
                if (!isMonorepo()) {
                    return [commit, line];
                }
                const lernaPackages = await this.getLernaPackages();
                const lernaJson = getLernaJson();
                const packages = await changedPackages({
                    sha: commit.hash,
                    packages: lernaPackages,
                    lernaJson,
                    logger: auto.logger,
                    version
                });
                const section = packages && packages.length
                    ? packages.map(p => `\`${p}\``).join(', ')
                    : 'monorepo';
                if (section === 'monorepo') {
                    return [commit, line];
                }
                return [commit, [`- ${section}`, `  ${line}`].join('\n')];
            });
        });
        auto.hooks.version.tapPromise(this.name, async (version) => {
            await checkClean(auto);
            if (isMonorepo()) {
                auto.logger.verbose.info('Detected monorepo, using lerna');
                const isIndependent = getLernaJson().version === 'independent';
                const monorepoBump = isIndependent
                    ? undefined
                    : await bumpLatest(getMonorepoPackage(), version);
                await core_1.execPromise('npx', [
                    'lerna',
                    'version',
                    monorepoBump || version,
                    !isIndependent && this.forcePublish && '--force-publish',
                    '--no-commit-hooks',
                    '--yes',
                    '-m',
                    "'Bump version to: %v [skip ci]'",
                    ...verboseArgs
                ]);
                auto.logger.verbose.info('Successfully versioned repo');
                return;
            }
            const latestBump = await bumpLatest(await utils_1.loadPackageJson(), version);
            await core_1.execPromise('npm', [
                'version',
                latestBump || version,
                '-m',
                '"Bump version to: %s [skip ci]"',
                ...verboseArgs
            ]);
            auto.logger.verbose.info('Successfully versioned repo');
        });
        auto.hooks.canary.tapPromise(this.name, async (version, postFix) => {
            await checkClean(auto);
            if (this.setRcToken) {
                await set_npm_token_1.default(auto.logger);
                auto.logger.verbose.info('Set CI NPM_TOKEN');
            }
            if (isMonorepo()) {
                auto.logger.verbose.info('Detected monorepo, using lerna');
                await core_1.execPromise('npx', [
                    'lerna',
                    'publish',
                    `pre${version}`,
                    '--dist-tag',
                    'canary',
                    '--preid',
                    `canary${postFix}`,
                    '--force-publish',
                    '--yes',
                    '--no-git-reset',
                    '--no-git-tag-version',
                    '--exact',
                    ...verboseArgs
                ]);
                auto.logger.verbose.info('Successfully published canary version');
                const packages = await this.getLernaPackages();
                const independentPackages = await this.getIndependentPackageList();
                // Reset after we read the packages from the system
                await core_1.execPromise('git', ['reset', '--hard', 'HEAD']);
                if (getLernaJson().version === 'independent') {
                    if (!independentPackages.includes('canary')) {
                        return { error: 'No packages were changed. No canary published.' };
                    }
                    return `<details><summary>Canary Versions</summary>${independentPackages}</details>`;
                }
                const versioned = packages.find(p => p.version.includes('canary'));
                if (!versioned) {
                    return { error: 'No packages were changed. No canary published.' };
                }
                return versioned.version.split('+')[0];
            }
            auto.logger.verbose.info('Detected single npm package');
            const { private: isPrivate, name } = await utils_1.loadPackageJson();
            const lastRelease = await auto.git.getLatestRelease();
            const current = await auto.getCurrentVersion(lastRelease);
            const nextVersion = semver_1.inc(current, version);
            const isScopedPackage = name.match(/@\S+\/\S+/);
            const canaryVersion = `${nextVersion}-canary${postFix}`;
            await core_1.execPromise('npm', [
                'version',
                canaryVersion,
                '--no-git-tag-version',
                ...verboseArgs
            ]);
            const publishArgs = ['--tag', 'canary'];
            await core_1.execPromise('npm', !isPrivate && isScopedPackage
                ? ['publish', '--access', 'public', ...publishArgs, ...verboseArgs]
                : ['publish', ...publishArgs, ...verboseArgs]);
            auto.logger.verbose.info('Successfully published canary version');
            return canaryVersion;
        });
        auto.hooks.publish.tapPromise(this.name, async () => {
            const status = await core_1.execPromise('git', ['status', '--porcelain']);
            if (isVerbose && status) {
                auto.logger.log.error('Changed Files:\n', status);
            }
            if (this.setRcToken) {
                await set_npm_token_1.default(auto.logger);
                auto.logger.verbose.info('Set CI NPM_TOKEN');
            }
            if (isMonorepo()) {
                auto.logger.verbose.info('Detected monorepo, using lerna');
                if (auto.options && auto.options.verbose) {
                    await core_1.execPromise('git', ['status', '--short']);
                }
                await core_1.execPromise('npx', [
                    'lerna',
                    'publish',
                    '--yes',
                    'from-git',
                    ...verboseArgs
                ]);
                auto.logger.verbose.info('Successfully published repo');
                return;
            }
            const { private: isPrivate, name } = await utils_1.loadPackageJson();
            const isScopedPackage = name.match(/@\S+\/\S+/);
            await core_1.execPromise('npm', !isPrivate && isScopedPackage
                ? ['publish', '--access', 'public', ...verboseArgs]
                : ['publish', ...verboseArgs]);
            await core_1.execPromise('git', [
                'push',
                '--follow-tags',
                '--set-upstream',
                'origin',
                auto.baseBranch
            ]);
            auto.logger.verbose.info('Successfully published repo');
        });
    }
}
tslib_1.__decorate([
    typescript_memoize_1.Memoize()
], NPMPlugin.prototype, "getLernaPackages", null);
tslib_1.__decorate([
    typescript_memoize_1.Memoize()
], NPMPlugin.prototype, "getIndependentPackageList", null);
exports.default = NPMPlugin;
//# sourceMappingURL=index.js.map