"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const dotenv_1 = tslib_1.__importDefault(require("dotenv"));
const env_ci_1 = tslib_1.__importDefault(require("env-ci"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const semver_1 = require("semver");
const https_proxy_agent_1 = tslib_1.__importDefault(require("https-proxy-agent"));
const config_1 = tslib_1.__importDefault(require("./config"));
const git_1 = tslib_1.__importDefault(require("./git"));
const init_1 = tslib_1.__importDefault(require("./init"));
const release_1 = tslib_1.__importStar(require("./release"));
const semver_2 = tslib_1.__importStar(require("./semver"));
const exec_promise_1 = tslib_1.__importDefault(require("./utils/exec-promise"));
const load_plugins_1 = tslib_1.__importDefault(require("./utils/load-plugins"));
const logger_1 = tslib_1.__importDefault(require("./utils/logger"));
const make_hooks_1 = require("./utils/make-hooks");
const proxyUrl = process.env.https_proxy || process.env.http_proxy;
const env = env_ci_1.default();
const loadEnv = () => {
    const envFile = path_1.default.resolve(process.cwd(), '.env');
    if (!fs_1.default.existsSync(envFile)) {
        return;
    }
    const envConfig = dotenv_1.default.parse(fs_1.default.readFileSync(envFile));
    Object.entries(envConfig).forEach(([key, value]) => {
        process.env[key] = value;
    });
};
class Auto {
    constructor(options = {}) {
        this.prefixRelease = (release) => {
            if (!this.release) {
                throw this.createErrorMessage();
            }
            return this.release.options.noVersionPrefix || release.startsWith('v')
                ? release
                : `v${release}`;
        };
        this.options = options;
        this.baseBranch = options.baseBranch || 'master';
        this.logger = logger_1.default(options.veryVerbose
            ? 'veryVerbose'
            : options.verbose
                ? 'verbose'
                : undefined);
        this.hooks = make_hooks_1.makeHooks();
        this.hooks.onCreateRelease.tap('Link onCreateChangelog', release => {
            release.hooks.onCreateChangelog.tap('Link onCreateChangelog', (changelog, version) => {
                this.hooks.onCreateChangelog.call(changelog, version);
            });
        });
        this.hooks.onCreateRelease.tap('Link onCreateLogParse', release => {
            release.hooks.onCreateLogParse.tap('Link onCreateLogParse', logParse => {
                this.hooks.onCreateLogParse.call(logParse);
            });
        });
        loadEnv();
        this.logger.verbose.info('ENV:', env);
    }
    /**
     * Load the .autorc from the file system, set up defaults, combine with CLI args
     * load the extends property, load the plugins and start the git remote interface.
     */
    async loadConfig() {
        const configLoader = new config_1.default(this.logger);
        const config = this.hooks.modifyConfig.call(Object.assign(Object.assign({}, (await configLoader.loadConfig(this.options))), { baseBranch: this.baseBranch }));
        this.logger.verbose.success('Loaded `auto` with config:', config);
        this.config = config;
        this.labels = config.labels;
        this.semVerLabels = release_1.getVersionMap(config.labels);
        this.loadPlugins(config);
        this.hooks.beforeRun.call(config);
        const repository = await this.getRepo(config);
        const token = repository && repository.token ? repository.token : process.env.GH_TOKEN;
        if (!token || token === 'undefined') {
            this.logger.log.error('No GitHub was found. Make sure it is available on process.env.GH_TOKEN.');
            throw new Error('GitHub token not found!');
        }
        const githubOptions = Object.assign(Object.assign({ owner: config.owner, repo: config.repo }, repository), { token, agent: proxyUrl ? new https_proxy_agent_1.default(proxyUrl) : undefined, baseUrl: config.githubApi || 'https://api.github.com', graphqlBaseUrl: config.githubGraphqlApi || config.githubApi || 'https://api.github.com' });
        this.git = this.startGit(githubOptions);
        this.release = new release_1.default(this.git, config, this.logger);
        this.hooks.onCreateRelease.call(this.release);
    }
    /**
     * Interactive prompt for initializing an .autorc
     */
    async init(options = {}) {
        await init_1.default(options, this.logger);
    }
    /**
     * Create all of the user's labels on the git remote if the don't already exist
     *
     * @param options Options for the createLabels functionality
     */
    async createLabels(options = {}) {
        if (!this.release || !this.labels) {
            throw this.createErrorMessage();
        }
        await this.release.addLabelsToProject(this.labels, options);
    }
    /**
     * Get the labels on a specific PR. Defaults to the labels of the last merged PR
     *
     * @param options Options for the createLabels functionality
     */
    async label({ pr } = {}) {
        if (!this.git) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info("Using command: 'label'");
        let labels = [];
        if (pr) {
            labels = await this.git.getLabels(pr);
        }
        else {
            const pulls = await this.git.getPullRequests({
                state: 'closed'
            });
            const lastMerged = pulls
                .sort((a, b) => new Date(b.merged_at).getTime() - new Date(a.merged_at).getTime())
                .find(pull => pull.merged_at);
            if (lastMerged) {
                labels = lastMerged.labels.map(label => label.name);
            }
        }
        if (labels.length) {
            console.log(labels.join('\n'));
        }
    }
    /**
     * Create a status on a PR.
     *
     * @param options Options for the pr status functionality
     */
    async prStatus(_a) {
        var { dryRun, pr, url } = _a, options = tslib_1.__rest(_a, ["dryRun", "pr", "url"]);
        if (!this.git) {
            throw this.createErrorMessage();
        }
        let { sha } = options;
        let prNumber;
        try {
            prNumber = this.getPrNumber('pr', pr);
        }
        catch (error) {
            // default to sha if no PR found
        }
        this.logger.verbose.info("Using command: 'pr-status'");
        if (!sha && prNumber) {
            this.logger.verbose.info('Getting commit SHA from PR.');
            const res = await this.git.getPullRequest(prNumber);
            sha = res.data.head.sha;
        }
        else if (!sha) {
            this.logger.verbose.info('No PR found, getting commit SHA from HEAD.');
            sha = await this.git.getSha();
        }
        this.logger.verbose.info('Found PR SHA:', sha);
        // tslint:disable-next-line variable-name
        const target_url = url;
        if (dryRun) {
            this.logger.verbose.info('`pr` dry run complete.');
        }
        else {
            try {
                await this.git.createStatus(Object.assign(Object.assign({}, options), { sha,
                    target_url }));
            }
            catch (error) {
                throw new Error(`Failed to post status to Pull Request with error code ${error.status}`);
            }
            this.logger.log.success('Posted status to Pull Request.');
        }
        this.logger.verbose.success('Finished `pr` command');
    }
    /**
     * Check that a PR has a SEMVER label. Set a success status on the PR.
     *
     * @param options Options for the pr check functionality
     */
    async prCheck(_a) {
        var { dryRun, pr, url } = _a, options = tslib_1.__rest(_a, ["dryRun", "pr", "url"]);
        if (!this.git || !this.release || !this.semVerLabels) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info(`Using command: 'pr-check' for '${url}'`);
        // tslint:disable-next-line variable-name
        const target_url = url;
        const prNumber = this.getPrNumber('prCheck', pr);
        let msg;
        let sha;
        try {
            const res = await this.git.getPullRequest(prNumber);
            sha = res.data.head.sha;
            const labels = await this.git.getLabels(prNumber);
            const labelValues = [...this.semVerLabels.values()];
            const releaseTag = labels.find(l => l === 'release');
            const skipReleaseTag = labels.find(l => this.release && this.release.options.skipReleaseLabels.includes(l));
            const semverTag = labels.find(l => labelValues.some(labelValue => labelValue.includes(l)) &&
                this.release &&
                !this.release.options.skipReleaseLabels.includes(l) &&
                l !== 'release');
            if (semverTag === undefined && !skipReleaseTag) {
                throw new Error('No semver label!');
            }
            this.logger.log.success(`PR is using label: ${semverTag || skipReleaseTag}`);
            let description;
            if (skipReleaseTag) {
                description = 'PR will not create a release';
            }
            else if (releaseTag) {
                description = `PR will create release once merged - ${semverTag}`;
            }
            else {
                description = `CI - ${semverTag}`;
            }
            msg = {
                description,
                state: 'success'
            };
        }
        catch (error) {
            msg = {
                description: error.message,
                state: 'error'
            };
        }
        this.logger.verbose.info('Posting status to GitHub\n', msg);
        if (dryRun) {
            this.logger.verbose.info('`pr-check` dry run complete.');
        }
        else {
            try {
                await this.git.createStatus(Object.assign(Object.assign(Object.assign({}, options), msg), { target_url,
                    sha }));
                this.logger.log.success('Posted status to Pull Request.');
            }
            catch (error) {
                throw new Error(`Failed to post status to Pull Request with error code ${error.status}`);
            }
        }
        this.logger.verbose.success('Finished `pr-check` command');
    }
    /**
     * Comment on a PR. Only one comment will be present on the PR, Older comments are removed.
     * You can use the "context" option to multiple comments on a PR.
     *
     * @param options Options for the comment functionality
     */
    async comment(options) {
        const { message, pr, context = 'default', dryRun, delete: deleteFlag, edit: editFlag } = options;
        if (!this.git) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info("Using command: 'comment'");
        const prNumber = this.getPrNumber('comment', pr);
        if (dryRun) {
            if (deleteFlag) {
                this.logger.log.info(`Would have deleted comment on ${prNumber} under "${context}" context`);
            }
            else if (editFlag) {
                this.logger.log.info(`Would have edited the comment on ${prNumber} under "${context}" context.\n\nNew message: ${message}`);
            }
            else {
                this.logger.log.info(`Would have commented on ${prNumber} under "${context}" context:\n\n${message}`);
            }
        }
        else if (editFlag && message) {
            await this.git.editComment(message, prNumber, context);
            this.logger.log.success(`Edited comment on PR #${prNumber} under context "${context}"`);
        }
        else {
            if (deleteFlag) {
                await this.git.deleteComment(prNumber, context);
                this.logger.log.success(`Deleted comment on PR #${prNumber} under context "${context}"`);
            }
            if (message) {
                await this.git.createComment(message, prNumber, context);
                this.logger.log.success(`Commented on PR #${prNumber}`);
            }
        }
    }
    /**
     * Update the body of a PR with a message. Only one message will be present in the PR,
     * Older messages are removed. You can use the "context" option to multiple message
     * in a PR body.
     *
     * @param options Options
     */
    async prBody(options) {
        const { message, pr, context = 'default', dryRun, delete: deleteFlag } = options;
        if (!this.git) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info("Using command: 'pr-body'");
        const prNumber = this.getPrNumber('pr-body', pr);
        if (dryRun) {
            if (deleteFlag) {
                this.logger.log.info(`Would have deleted PR body on ${prNumber} under "${context}" context`);
            }
            else {
                this.logger.log.info(`Would have appended to PR body on ${prNumber} under "${context}" context:\n\n${message}`);
            }
        }
        else {
            if (deleteFlag) {
                await this.git.addToPrBody('', prNumber, context);
            }
            if (message) {
                await this.git.addToPrBody(message, prNumber, context);
            }
            this.logger.log.success(`Updated body on PR #${prNumber}`);
        }
    }
    /**
     * Calculate the version bump for the current state of the repository.
     */
    async version(options = {}) {
        this.logger.verbose.info("Using command: 'version'");
        const bump = await this.getVersion(options);
        console.log(bump);
    }
    /**
     * Calculate the the changelog and commit it.
     */
    async changelog(options) {
        this.logger.verbose.info("Using command: 'changelog'");
        await this.makeChangelog(options);
    }
    /**
     * Make a release to the git remote with the changes.
     */
    async runRelease(options = {}) {
        this.logger.verbose.info("Using command: 'release'");
        await this.makeRelease(options);
    }
    async canary(options = {}) {
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        // SailEnv falls back to commit SHA
        let pr;
        let build;
        if ('pr' in env && 'build' in env) {
            ({ pr } = env);
            ({ build } = env);
        }
        else if ('pr' in env && 'commit' in env) {
            ({ pr } = env);
            build = env.commit;
        }
        pr = options.pr ? String(options.pr) : pr;
        build = options.build ? String(options.build) : build;
        this.logger.verbose.info('Canary info found:', { pr, build });
        const head = await this.release.getCommitsInRelease('HEAD^');
        const labels = head.map(commit => commit.labels);
        const version = semver_2.calculateSemVerBump(labels, this.semVerLabels, this.config) ||
            semver_2.default.patch;
        let canaryVersion = '';
        if (pr) {
            canaryVersion = `${canaryVersion}.${pr}`;
        }
        if (build) {
            canaryVersion = `${canaryVersion}.${build}`;
        }
        if (!pr || !build) {
            canaryVersion = `${canaryVersion}.${await this.git.getSha(true)}`;
        }
        let newVersion = '';
        if (options.dryRun) {
            this.logger.log.warn(`Published canary identifier would be: "-canary${canaryVersion}"`);
        }
        else {
            this.logger.verbose.info('Calling canary hook');
            const result = await this.hooks.canary.promise(version, canaryVersion);
            if (typeof result === 'object') {
                this.logger.log.warn(result.error);
                return;
            }
            newVersion = result;
            const message = options.message || 'Published PR with canary version: %v';
            if (message !== 'false' && pr) {
                await this.prBody({
                    pr: Number(pr),
                    message: message.replace('%v', !newVersion || newVersion.includes('\n')
                        ? newVersion
                        : `\`${newVersion}\``),
                    context: 'canary-version'
                });
            }
            this.logger.log.success(`Published canary version${newVersion ? `: ${newVersion}` : ''}`);
        }
        let latestTag;
        try {
            latestTag = await this.git.getLatestTagInBranch();
        }
        catch (error) {
            latestTag = await this.git.getFirstCommit();
        }
        const commitsInRelease = await this.release.getCommits(latestTag);
        return { newVersion, commitsInRelease };
    }
    /**
     * Run the full workflow.
     *
     * 1. Calculate version
     * 2. Make changelog
     * 3. Publish code
     * 4. Create a release
     */
    async shipit(options = {}) {
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info("Using command: 'shipit'");
        this.hooks.beforeShipIt.call();
        // env-ci sets branch to target branch (ex: master) in some CI services.
        // so we should make sure we aren't in a PR just to be safe
        const isPR = 'isPr' in env && env.isPr;
        const isBaseBranch = !isPR && 'branch' in env && env.branch === this.baseBranch;
        const publishInfo = isBaseBranch
            ? await this.publishLatest(options)
            : await this.canary(options);
        if (!publishInfo) {
            return;
        }
        const { newVersion, commitsInRelease } = publishInfo;
        await this.hooks.afterShipIt.promise(newVersion, commitsInRelease);
    }
    async getCurrentVersion(lastRelease) {
        this.hooks.getPreviousVersion.tap('None', () => {
            this.logger.veryVerbose.info('No previous release found, using 0.0.0 as previous version.');
            return this.prefixRelease('0.0.0');
        });
        const lastVersion = await this.hooks.getPreviousVersion.promise(this.prefixRelease);
        if (semver_1.parse(lastRelease) &&
            semver_1.parse(lastVersion) &&
            semver_1.gt(lastRelease, lastVersion)) {
            this.logger.veryVerbose.info('Using latest release as previous version');
            return lastRelease;
        }
        return lastVersion;
    }
    /**
     * A utility function for plugins to check the process for tokens.
     */
    checkEnv(pluginName, key) {
        if (!process.env[key]) {
            this.logger.log.warn(`${pluginName}: No "${key}" found in environment`);
        }
    }
    async publishLatest(options) {
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        const version = await this.getVersion();
        if (version === '') {
            this.logger.log.info('No version published.');
            return;
        }
        const lastRelease = await this.git.getLatestRelease();
        const commitsInRelease = await this.release.getCommitsInRelease(lastRelease);
        await this.makeChangelog(options);
        if (!options.dryRun) {
            this.logger.verbose.info('Calling version hook');
            await this.hooks.version.promise(version);
            this.logger.verbose.info('Calling after version hook');
            await this.hooks.afterVersion.promise();
            this.logger.verbose.info('Calling publish hook');
            await this.hooks.publish.promise(version);
            this.logger.verbose.info('Calling after publish hook');
            await this.hooks.afterPublish.promise();
        }
        const newVersion = await this.makeRelease(options);
        if (options.dryRun) {
            this.logger.log.warn("The version reported in the line above hasn't been incremented during `dry-run`");
            const current = await this.getCurrentVersion(lastRelease);
            if (semver_1.parse(current)) {
                this.logger.log.warn(`Published version would be: ${semver_1.inc(current, version)}`);
            }
        }
        return { newVersion, commitsInRelease };
    }
    getPrNumber(command, pr) {
        const envPr = 'pr' in env && Number(env.pr);
        const prNumber = pr || envPr;
        if (!prNumber) {
            throw new Error(`Could not detect PR number. ${command} must be run from either a PR or have the PR number supllied via the --pr flag.`);
        }
        return prNumber;
    }
    startGit(gitOptions) {
        if (!gitOptions.owner || !gitOptions.repo || !gitOptions.token) {
            throw new Error('Must set owner, repo, and GitHub token.');
        }
        this.logger.verbose.info('Options contain repo information.');
        // So that --verbose can be used on public CIs
        const tokenlessArgs = Object.assign(Object.assign({}, gitOptions), { token: `[Token starting with ${gitOptions.token.substring(0, 4)}]` });
        this.logger.verbose.info('Initializing GitHub API with:\n', tokenlessArgs);
        return new git_1.default({
            owner: gitOptions.owner,
            repo: gitOptions.repo,
            token: gitOptions.token,
            baseUrl: gitOptions.baseUrl,
            graphqlBaseUrl: gitOptions.graphqlBaseUrl,
            agent: gitOptions.agent
        }, this.logger);
    }
    async getVersion({ from } = {}) {
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        const lastRelease = from || (await this.git.getLatestRelease());
        const bump = await this.release.getSemverBump(lastRelease);
        this.versionBump = bump;
        return bump;
    }
    async makeChangelog({ dryRun, from, to, message } = {}) {
        if (!this.release || !this.git) {
            throw this.createErrorMessage();
        }
        await this.setGitUser();
        const lastRelease = from || (await this.git.getLatestRelease());
        const releaseNotes = await this.release.generateReleaseNotes(lastRelease, to || undefined, this.versionBump);
        this.logger.log.info('New Release Notes\n', releaseNotes);
        if (dryRun) {
            this.logger.verbose.info('`changelog` dry run complete.');
            return;
        }
        const currentVersion = await this.getCurrentVersion(lastRelease);
        await this.release.addToChangelog(releaseNotes, lastRelease, currentVersion, message);
        await this.hooks.afterAddToChangelog.promise({
            commits: await this.release.getCommitsInRelease(lastRelease, to || undefined),
            releaseNotes,
            lastRelease,
            currentVersion
        });
    }
    async makeRelease({ dryRun, from, useVersion } = {}) {
        if (!this.release || !this.git) {
            throw this.createErrorMessage();
        }
        let lastRelease = from || (await this.git.getLatestRelease());
        // Find base commit or latest release to generate the changelog to HEAD (new tag)
        this.logger.veryVerbose.info(`Using ${lastRelease} as previous release.`);
        if (lastRelease.match(/^\d+\.\d+\.\d+/)) {
            lastRelease = this.prefixRelease(lastRelease);
        }
        this.logger.log.info('Last used release:', lastRelease);
        const commitsInRelease = await this.release.getCommitsInRelease(lastRelease);
        const releaseNotes = await this.release.generateReleaseNotes(lastRelease, undefined, this.versionBump);
        this.logger.log.info(`Using release notes:\n${releaseNotes}`);
        const rawVersion = useVersion ||
            (await this.getCurrentVersion(lastRelease)) ||
            (await this.git.getLatestTagInBranch());
        if (!rawVersion) {
            this.logger.log.error('Could not calculate next version from last tag.');
            return;
        }
        const newVersion = semver_1.parse(rawVersion)
            ? this.prefixRelease(rawVersion)
            : rawVersion;
        if (!dryRun &&
            semver_1.parse(newVersion) &&
            semver_1.parse(lastRelease) &&
            semver_1.eq(newVersion, lastRelease)) {
            this.logger.log.warn(`Nothing released to Github. Version to be released is the same as the latest release on Github: ${newVersion}`);
            return;
        }
        let release;
        if (dryRun) {
            this.logger.log.info(`Would have released (unless ran with "shipit"): ${newVersion}`);
        }
        else {
            this.logger.log.info(`Releasing ${newVersion} to GitHub.`);
            release = await this.git.publish(releaseNotes, newVersion);
        }
        await this.hooks.afterRelease.promise({
            lastRelease,
            newVersion,
            commits: commitsInRelease,
            releaseNotes,
            response: release
        });
        return newVersion;
    }
    createErrorMessage() {
        return new Error(`Auto is not initialized! Make sure the have run Auto.loadConfig`);
    }
    /**
     * Set the git user to make releases and commit with.
     */
    async setGitUser() {
        try {
            // If these values are not set git config will exit with an error
            await exec_promise_1.default('git', ['config', 'user.email']);
            await exec_promise_1.default('git', ['config', 'user.name']);
        }
        catch (error) {
            this.logger.verbose.warn('Could not find git user or email configured in environment');
            if (!env.isCi) {
                this.logger.log.note(`Detected local environment, will not set git user. This happens automatically in a CI environment.

If a command fails manually run:

  - git config user.email your@email.com
  - git config user.name "Your Name"`);
                return;
            }
            if (!this.release) {
                return;
            }
            let { email, name } = this.release.options;
            this.logger.verbose.warn(`Got author from options: email: ${email}, name ${name}`);
            const packageAuthor = await this.hooks.getAuthor.promise();
            this.logger.verbose.warn(`Got author: ${JSON.stringify(packageAuthor, undefined, 2)}`);
            email = !email && packageAuthor ? packageAuthor.email : email;
            name = !name && packageAuthor ? packageAuthor.name : name;
            if (email) {
                await exec_promise_1.default('git', ['config', 'user.email', `"${email}"`]);
                this.logger.verbose.warn(`Set git email to ${email}`);
            }
            if (name) {
                await exec_promise_1.default('git', ['config', 'user.name', `"${name}"`]);
                this.logger.verbose.warn(`Set git name to ${name}`);
            }
        }
    }
    async getRepo(config) {
        if (config.owner && config.repo) {
            return config;
        }
        return this.hooks.getRepository.promise();
    }
    /**
     * Apply all of the plugins in the config.
     */
    loadPlugins(config) {
        const pluginsPaths = [
            require.resolve('./plugins/filter-non-pull-request'),
            ...(config.plugins || ['npm'])
        ];
        pluginsPaths
            .map(plugin => 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        typeof plugin === 'string' ? [plugin, {}] : plugin)
            .map(plugin => load_plugins_1.default(plugin, this.logger))
            .filter((plugin) => Boolean(plugin))
            .forEach(plugin => {
            this.logger.verbose.info(`Using ${plugin.name} Plugin...`);
            plugin.apply(this);
        });
    }
}
exports.default = Auto;
var auto_1 = require("./auto");
exports.Auto = auto_1.default;
var semver_3 = require("./semver");
exports.SEMVER = semver_3.default;
var exec_promise_2 = require("./utils/exec-promise");
exports.execPromise = exec_promise_2.default;
//# sourceMappingURL=auto.js.map