import { ReposCreateReleaseResponse, Response } from '@octokit/rest';
import { AsyncParallelHook, AsyncSeriesBailHook, SyncHook, SyncWaterfallHook } from 'tapable';
import { ApiOptions, ICanaryOptions, IChangelogOptions, ICommentOptions, ICreateLabelsOptions, IInitOptions, ILabelOptions, IPRCheckOptions, IPRStatusOptions, IReleaseOptions, IShipItOptions, IVersionOptions } from './auto-args';
import Changelog from './changelog';
import Git from './git';
import LogParse, { IExtendedCommit } from './log-parse';
import Release, { IAutoConfig, ILabelDefinitionMap } from './release';
import SEMVER, { IVersionLabels } from './semver';
import { ILogger } from './utils/logger';
interface IAuthor {
    name?: string;
    email?: string;
}
interface IRepository {
    owner?: string;
    repo?: string;
    token?: string;
}
export interface IAutoHooks {
    modifyConfig: SyncWaterfallHook<[IAutoConfig]>;
    beforeRun: SyncHook<[IAutoConfig]>;
    beforeShipIt: SyncHook<[]>;
    afterAddToChangelog: AsyncParallelHook<[{
        commits: IExtendedCommit[];
        releaseNotes: string;
        currentVersion: string;
        lastRelease: string;
    }]>;
    afterShipIt: AsyncParallelHook<[string | undefined, IExtendedCommit[]]>;
    afterRelease: AsyncParallelHook<[{
        lastRelease: string;
        newVersion?: string;
        commits: IExtendedCommit[];
        releaseNotes: string;
        response?: Response<ReposCreateReleaseResponse>;
    }]>;
    getAuthor: AsyncSeriesBailHook<[], IAuthor | void>;
    getPreviousVersion: AsyncSeriesBailHook<[(release: string) => string], string>;
    getRepository: AsyncSeriesBailHook<[], IRepository | void>;
    onCreateRelease: SyncHook<[Release]>;
    onCreateLogParse: SyncHook<[LogParse]>;
    onCreateChangelog: SyncHook<[Changelog, SEMVER | undefined]>;
    version: AsyncParallelHook<[SEMVER]>;
    afterVersion: AsyncParallelHook<[]>;
    publish: AsyncParallelHook<[SEMVER]>;
    canary: AsyncSeriesBailHook<[SEMVER, string], string | {
        error: string;
    }>;
    afterPublish: AsyncParallelHook<[]>;
}
export default class Auto {
    hooks: IAutoHooks;
    logger: ILogger;
    options: ApiOptions;
    baseBranch: string;
    config?: IAutoConfig;
    release?: Release;
    git?: Git;
    labels?: ILabelDefinitionMap;
    semVerLabels?: IVersionLabels;
    private versionBump?;
    constructor(options?: ApiOptions);
    /**
     * Load the .autorc from the file system, set up defaults, combine with CLI args
     * load the extends property, load the plugins and start the git remote interface.
     */
    loadConfig(): Promise<void>;
    /**
     * Interactive prompt for initializing an .autorc
     */
    init(options?: IInitOptions): Promise<void>;
    /**
     * Create all of the user's labels on the git remote if the don't already exist
     *
     * @param options Options for the createLabels functionality
     */
    createLabels(options?: ICreateLabelsOptions): Promise<void>;
    /**
     * Get the labels on a specific PR. Defaults to the labels of the last merged PR
     *
     * @param options Options for the createLabels functionality
     */
    label({ pr }?: ILabelOptions): Promise<void>;
    /**
     * Create a status on a PR.
     *
     * @param options Options for the pr status functionality
     */
    prStatus({ dryRun, pr, url, ...options }: IPRStatusOptions): Promise<void>;
    /**
     * Check that a PR has a SEMVER label. Set a success status on the PR.
     *
     * @param options Options for the pr check functionality
     */
    prCheck({ dryRun, pr, url, ...options }: IPRCheckOptions): Promise<void>;
    /**
     * Comment on a PR. Only one comment will be present on the PR, Older comments are removed.
     * You can use the "context" option to multiple comments on a PR.
     *
     * @param options Options for the comment functionality
     */
    comment(options: ICommentOptions): Promise<void>;
    /**
     * Update the body of a PR with a message. Only one message will be present in the PR,
     * Older messages are removed. You can use the "context" option to multiple message
     * in a PR body.
     *
     * @param options Options
     */
    prBody(options: ICommentOptions): Promise<void>;
    /**
     * Calculate the version bump for the current state of the repository.
     */
    version(options?: IVersionOptions): Promise<void>;
    /**
     * Calculate the the changelog and commit it.
     */
    changelog(options?: IChangelogOptions): Promise<void>;
    /**
     * Make a release to the git remote with the changes.
     */
    runRelease(options?: IReleaseOptions): Promise<void>;
    canary(options?: ICanaryOptions): Promise<{
        newVersion: string;
        commitsInRelease: IExtendedCommit[];
    } | undefined>;
    /**
     * Run the full workflow.
     *
     * 1. Calculate version
     * 2. Make changelog
     * 3. Publish code
     * 4. Create a release
     */
    shipit(options?: IShipItOptions): Promise<void>;
    getCurrentVersion(lastRelease: string): Promise<string>;
    /**
     * A utility function for plugins to check the process for tokens.
     */
    checkEnv(pluginName: string, key: string): void;
    private publishLatest;
    private getPrNumber;
    private startGit;
    private getVersion;
    private makeChangelog;
    private makeRelease;
    private readonly prefixRelease;
    private createErrorMessage;
    /**
     * Set the git user to make releases and commit with.
     */
    private setGitUser;
    private getRepo;
    /**
     * Apply all of the plugins in the config.
     */
    private loadPlugins;
}
export * from './auto-args';
export { ILogger } from './utils/logger';
export { IPlugin } from './utils/load-plugins';
export { default as Auto } from './auto';
export { default as SEMVER } from './semver';
export { default as execPromise } from './utils/exec-promise';
export { VersionLabel } from './release';
//# sourceMappingURL=auto.d.ts.map