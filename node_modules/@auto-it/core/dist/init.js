"use strict";
/* eslint-disable no-await-in-loop, @typescript-eslint/ban-ts-ignore */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const dedent_1 = tslib_1.__importDefault(require("dedent"));
const enquirer_1 = require("enquirer");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const util_1 = require("util");
const release_1 = require("./release");
const writeFile = util_1.promisify(fs.writeFile);
const isObject = (value) => typeof value === 'object' && value !== null;
async function getFlags() {
    return enquirer_1.prompt([
        {
            type: 'input',
            name: 'repo',
            message: 'GitHub Project Repository (press enter to use package definition)'
        },
        {
            type: 'input',
            name: 'owner',
            message: 'GitHub Project Owner (press enter to use package definition)'
        },
        {
            type: 'confirm',
            name: 'noVersionPrefix',
            message: 'Use the version as the tag without the `v` prefix?',
            initial: 'no'
        },
        {
            type: 'input',
            name: 'githubApi',
            message: 'GitHub API to use (press enter to use public)'
        },
        {
            type: 'input',
            name: 'githubGraphqlApi',
            message: 'GitHub Graphql API base path to use (press enter to use githubApi)'
        },
        {
            type: 'input',
            name: 'baseBranch',
            message: 'Branch to treat as the "master" branch (press enter to use "master")'
        },
        {
            type: 'confirm',
            name: 'onlyPublishWithReleaseLabel',
            message: 'Only bump version if `release` label is on pull request',
            initial: 'no'
        },
        {
            type: 'input',
            name: 'name',
            message: 'Git name to commit and release with (press enter to use package definition)'
        },
        {
            type: 'input',
            name: 'email',
            message: 'Git email to commit with (press enter to use package definition)'
        }
    ]);
}
async function getCustomLabels(onlyLabels = false) {
    const useCustomChangelogTitles = onlyLabels
        ? { value: onlyLabels }
        : await enquirer_1.prompt({
            type: 'confirm',
            name: 'value',
            message: 'Would you like to use custom labels?',
            initial: 'no'
        });
    let customLabels = {};
    if (useCustomChangelogTitles.value) {
        const labels = Object.entries(release_1.defaultLabelDefinition);
        let i = 0;
        while (labels[i]) {
            const [labelName, labelDef] = labels[i++];
            const response = await enquirer_1.prompt({
                type: 'snippet',
                name: 'value',
                message: `Customize the ${labelName} label:`,
                initial: labelDef,
                // @ts-ignore
                template: labelName === 'release' || labelName === 'skip-release'
                    ? dedent_1.default `
                label:  #{name}
                desc:   #{description}
              `
                    : dedent_1.default `
                label:  #{name}
                title:  #{title}
                desc:   #{description}
              `
            });
            const { name, title, description } = response.value.values;
            const newLabel = {};
            if (!labelDef.some(l => name !== l.name)) {
                newLabel.name = name;
            }
            if (!labelDef.some(l => title !== l.title)) {
                newLabel.title = title;
            }
            if (!labelDef.some(l => description !== l.description)) {
                newLabel.description = description;
            }
            if (Object.keys(newLabel).length === 1 && newLabel.name) {
                customLabels = Object.assign(Object.assign({}, customLabels), { [labelName]: name });
            }
            else if (Object.keys(newLabel).length !== 0) {
                customLabels = Object.assign(Object.assign({}, customLabels), { [labelName]: newLabel });
            }
        }
    }
    let getAnotherTitle = await enquirer_1.prompt({
        type: 'confirm',
        name: 'value',
        message: 'Would you like to add additional labels?',
        initial: 'no'
    });
    while (getAnotherTitle.value) {
        const response = await enquirer_1.prompt({
            type: 'snippet',
            name: 'value',
            message: 'Add another label:',
            // @ts-ignore
            template: dedent_1.default `
        label:  #{name}
        title:  #{title}
        desc:   #{description}
      `,
            validate: (state) => {
                if (!state.values.name) {
                    return 'Label is required for new label';
                }
                if (!state.values.title) {
                    return 'Title is required for new label';
                }
                if (!state.values.description) {
                    return 'Description is required for new label';
                }
                return true;
            }
        });
        const { name, title, description } = response.value.values;
        customLabels = Object.assign(Object.assign({}, customLabels), { [name]: { name, title, description } });
        getAnotherTitle = await enquirer_1.prompt({
            type: 'confirm',
            name: 'value',
            message: 'Would you like to add another?',
            initial: 'no'
        });
    }
    return customLabels;
}
async function init({ onlyLabels, dryRun }, logger) {
    const flags = onlyLabels ? {} : await getFlags();
    const labels = await getCustomLabels(onlyLabels);
    const autoRc = Object.entries(Object.assign(Object.assign({}, flags), { labels })).reduce((all, [key, value]) => {
        if (value === '' ||
            value === false ||
            (isObject(value) && Object.keys(value).length === 0)) {
            return all;
        }
        return Object.assign(Object.assign({}, all), { [key]: value });
    }, {});
    if (Object.keys(autoRc).length === 0) {
        return;
    }
    const jsonString = JSON.stringify(autoRc, undefined, 2);
    if (dryRun) {
        logger.log.note(`Initialization options would be:\n${jsonString}`);
    }
    else {
        await writeFile(path.join(process.cwd(), '.autorc'), jsonString);
    }
}
exports.default = init;
//# sourceMappingURL=init.js.map