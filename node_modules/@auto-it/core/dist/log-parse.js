"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const make_hooks_1 = require("./utils/make-hooks");
function parsePR(commit) {
    const merge = /Merge pull request #(\d+) from (.+)\n([\S\s]+)/;
    const prMatch = commit.subject.match(merge);
    if (!prMatch) {
        return commit;
    }
    return Object.assign(Object.assign({}, commit), { pullRequest: {
            number: Number(prMatch[1]),
            base: prMatch[2]
        }, subject: prMatch[3].trim() });
}
exports.parsePR = parsePR;
function parseSquashPR(commit) {
    const firstLine = commit.subject.split('\n')[0];
    const squashMerge = /\(#(\d+)\)$/;
    const squashMergeMatch = firstLine.match(squashMerge);
    if (!squashMergeMatch) {
        return commit;
    }
    return Object.assign(Object.assign({}, commit), { pullRequest: {
            number: Number(squashMergeMatch[1])
        }, subject: firstLine
            .substr(0, firstLine.length - squashMergeMatch[0].length)
            .trim() });
}
exports.parseSquashPR = parseSquashPR;
class LogParse {
    constructor() {
        this.hooks = make_hooks_1.makeLogParseHooks();
        this.hooks.parseCommit.tap('Merge Commit', parsePR);
        this.hooks.parseCommit.tap('Squash Merge Commit', parseSquashPR);
    }
    async normalizeCommits(commits) {
        const eCommits = await Promise.all(commits.map(async (commit) => this.normalizeCommit(commit)));
        return eCommits.filter(Boolean);
    }
    async normalizeCommit(commit) {
        const extended = await this.hooks.parseCommit.promise(Object.assign(Object.assign({ labels: [] }, commit), { authors: [{ name: commit.authorName, email: commit.authorEmail }] }));
        const shouldOmit = await this.hooks.omitCommit.promise(extended);
        if (shouldOmit) {
            return;
        }
        return extended;
    }
}
exports.default = LogParse;
//# sourceMappingURL=log-parse.js.map