"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const url_1 = require("url");
const url_join_1 = tslib_1.__importDefault(require("url-join"));
const make_hooks_1 = require("./utils/make-hooks");
const getHeaderDepth = (line) => line.split('').reduce((count, char) => (char === '#' ? count + 1 : count), 0);
const filterLabel = (commits, label) => commits.filter(commit => commit.labels.includes(label));
class Changelog {
    constructor(logger, options) {
        this.logger = logger;
        this.options = options;
        this.hooks = make_hooks_1.makeChangelogHooks();
        const pushToMasterLabel = {
            name: 'pushToBaseBranch',
            title: `⚠️  Pushed to ${options.baseBranch}`,
            description: 'N/A'
        };
        this.options.labels.pushToBaseBranch = this.options.labels.pushToBaseBranch
            ? this.options.labels.pushToBaseBranch.map(l => (Object.assign(Object.assign({}, pushToMasterLabel), l)))
            : [pushToMasterLabel];
    }
    loadDefaultHooks() {
        this.hooks.renderChangelogAuthor.tap('Default', (author, commit) => this.createUserLink(author, commit));
        this.hooks.renderChangelogAuthorLine.tap('Default', (author, user) => {
            const authorString = author.name && user ? `${author.name} (${user})` : user;
            return authorString ? `- ${authorString}` : undefined;
        });
        this.hooks.renderChangelogLine.tap('Default', ([commit, line]) => [
            commit,
            line
        ]);
        this.hooks.renderChangelogTitle.tap('Default', (label, changelogTitles) => `#### ${changelogTitles[label]}\n`);
        this.hooks.omitReleaseNotes.tap('Renovate', commit => {
            const names = ['renovate-pro[bot]', 'renovate-bot'];
            if (commit.authors.find(author => Boolean((author.name && names.includes(author.name)) ||
                (author.username && names.includes(author.username))))) {
                return true;
            }
        });
    }
    async generateReleaseNotes(commits) {
        if (commits.length === 0) {
            return '';
        }
        this.logger.verbose.info('Generating release notes for:\n', commits);
        const split = this.splitCommits(commits);
        this.logger.verbose.info('Split commits into groups');
        this.logger.veryVerbose.info('\n', split);
        const sections = [];
        const extraNotes = (await this.hooks.addToBody.promise([], commits)) || [];
        extraNotes.filter(Boolean).forEach(note => sections.push(note));
        await this.createReleaseNotesSection(commits, sections);
        this.logger.verbose.info('Added release notes to changelog');
        this.authors = this.getAllAuthors(split);
        await this.createLabelSection(split, sections);
        this.logger.verbose.info('Added groups to changelog');
        await this.createAuthorSection(sections);
        this.logger.verbose.info('Added authors to changelog');
        const result = sections.join('\n\n');
        this.logger.verbose.info('Successfully generated release notes.');
        return result;
    }
    createUserLink(author, commit) {
        const githubUrl = new url_1.URL(this.options.baseUrl).origin;
        if (author.username === 'invalid-email-address') {
            return;
        }
        return author.username
            ? `[@${author.username}](${url_join_1.default(githubUrl, author.username)})`
            : author.email || commit.authorEmail;
    }
    /**
     * Split commits into changelogTitle sections.
     */
    splitCommits(commits) {
        let currentCommits = [...commits];
        const order = ['major', 'minor', 'patch'];
        const sections = Object.entries(this.options.labels)
            .filter(([, label]) => label.some(l => l.title))
            .sort(([a], [b]) => {
            const bIndex = order.indexOf(b) + 1 || order.length + 1;
            const aIndex = order.indexOf(a) + 1 || order.length + 1;
            return aIndex - bIndex;
        })
            .map(([, labels]) => labels)
            .reduce((acc, item) => [...acc, ...item], []);
        const defaultPatchLabelName = this.getFirstLabelNameFromLabelKey(this.options.labels, 'patch');
        commits
            .filter(({ labels }) => 
        // in case pr commit doesn't contain a label for section inclusion
        !sections.some(section => labels.includes(section.name)) ||
            // in this case we auto attached a patch when it was merged
            (labels[0] === 'released' && labels.length === 1))
            .map(({ labels }) => labels.push(defaultPatchLabelName));
        return Object.assign({}, ...sections.map(label => {
            const matchedCommits = filterLabel(currentCommits, label.name);
            currentCommits = currentCommits.filter(commit => !matchedCommits.includes(commit));
            return matchedCommits.length === 0
                ? {}
                : { [label.name]: matchedCommits };
        }));
    }
    getFirstLabelNameFromLabelKey(labels, labelKey) {
        return ((labels[labelKey] && labels[labelKey][0] && labels[labelKey][0].name) ||
            labelKey);
    }
    async createUserLinkList(commit) {
        const result = new Set();
        await Promise.all(commit.authors.map(async (rawAuthor) => {
            const data = this.authors.find(([, commitAuthor]) => commitAuthor.name === rawAuthor.name ||
                commitAuthor.email === rawAuthor.email) || [{}, rawAuthor];
            const link = await this.hooks.renderChangelogAuthor.promise(data[1], commit, this.options);
            if (link) {
                result.add(link);
            }
        }));
        return [...result].join(' ');
    }
    async generateCommitNote(commit) {
        const subject = commit.subject ? commit.subject.trim() : '';
        let pr = '';
        if (commit.pullRequest && commit.pullRequest.number) {
            const prLink = url_join_1.default(this.options.baseUrl, 'pull', commit.pullRequest.number.toString());
            pr = `[#${commit.pullRequest.number}](${prLink})`;
        }
        const user = await this.createUserLinkList(commit);
        return `- ${subject} ${pr}${user ? ` (${user})` : ''}`;
    }
    getAllAuthors(split) {
        const commits = Object.values(split).reduce((labeledCommits, sectionCommits) => [...labeledCommits, ...sectionCommits], []);
        return commits
            .map(commit => commit.authors
            .filter(author => author.username !== 'invalid-email-address' &&
            (author.name || author.email || author.username))
            .map(author => [commit, author]))
            .reduce((all, more) => [...all, ...more], [])
            .sort(a => ('id' in a[1] ? 0 : 1));
    }
    async createAuthorSection(sections) {
        const authors = new Set();
        const authorsWithFullData = this.authors.map(([, author]) => author).filter(author => 'id' in author);
        await Promise.all(this.authors.map(async ([commit, author]) => {
            const info = authorsWithFullData.find(u => u.name === author.name || u.email === author.email) || author;
            const user = await this.hooks.renderChangelogAuthor.promise(info, commit, this.options);
            const authorEntry = await this.hooks.renderChangelogAuthorLine.promise(info, user);
            if (authorEntry && !authors.has(authorEntry)) {
                authors.add(authorEntry);
            }
        }));
        if (authors.size === 0) {
            return;
        }
        let authorSection = `#### Authors: ${authors.size}\n\n`;
        authorSection += [...authors].join('\n');
        sections.push(authorSection);
    }
    async createLabelSection(split, sections) {
        const changelogTitles = Object.entries(this.options.labels).reduce((titles, [, labels]) => {
            labels.forEach(labelDef => {
                if (labelDef.title) {
                    titles[labelDef.name] = labelDef.title;
                }
            });
            return titles;
        }, {});
        const labelSections = await Promise.all(Object.entries(split).map(async ([label, labelCommits]) => {
            const title = await this.hooks.renderChangelogTitle.promise(label, changelogTitles);
            const lines = new Set();
            await Promise.all(labelCommits.map(async (commit) => {
                const [, line] = await this.hooks.renderChangelogLine.promise([
                    commit,
                    await this.generateCommitNote(commit)
                ]);
                lines.add(line);
            }));
            return [
                title,
                [...lines].sort((a, b) => a.split('\n').length - b.split('\n').length)
            ];
        }));
        const mergedSections = labelSections.reduce((acc, [title, commits]) => (Object.assign(Object.assign({}, acc), { [title]: [...(acc[title] || []), ...commits] })), {});
        Object.entries(mergedSections)
            .map(([title, lines]) => [title, ...lines].join('\n'))
            .map(section => sections.push(section));
    }
    async createReleaseNotesSection(commits, sections) {
        if (!commits.length) {
            return;
        }
        let section = '';
        const visited = new Set();
        const included = await Promise.all(commits.map(async (commit) => {
            const omit = await this.hooks.omitReleaseNotes.promise(commit);
            if (!omit) {
                return commit;
            }
        }));
        included.forEach(commit => {
            if (!commit) {
                return;
            }
            const pr = commit.pullRequest;
            if (!pr || !pr.body) {
                return;
            }
            const title = /^[#]{0,5}[ ]*[R|r]elease [N|n]otes$/;
            const lines = pr.body.split('\n').map(line => line.replace(/\r$/, ''));
            const notesStart = lines.findIndex(line => Boolean(line.match(title)));
            if (notesStart === -1 || visited.has(pr.number)) {
                return;
            }
            const depth = getHeaderDepth(lines[notesStart]);
            visited.add(pr.number);
            let notes = '';
            for (let index = notesStart; index < lines.length; index++) {
                const line = lines[index];
                const isTitle = line.match(title);
                if (line.startsWith('#') && getHeaderDepth(line) <= depth && !isTitle) {
                    break;
                }
                if (!isTitle) {
                    notes += `${line}\n`;
                }
            }
            section += `_From #${pr.number}_\n\n${notes.trim()}\n\n`;
        });
        if (!section) {
            return;
        }
        sections.push(`### Release Notes\n\n${section}---`);
    }
}
exports.default = Changelog;
//# sourceMappingURL=changelog.js.map