"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const exec_promise_1 = tslib_1.__importDefault(require("../exec-promise"));
test('resolves stdout', async () => {
    expect(await exec_promise_1.default('echo', ['foo'])).toBe('foo');
});
test('filters out anything but strings', async () => {
    expect(await exec_promise_1.default('echo', ['foo', false, undefined, 'baz'])).toBe('foo baz');
});
test('fails correctly', async () => {
    expect.assertions(1);
    return expect(exec_promise_1.default('false')).rejects.toMatchInlineSnapshot(`[Error: Running command 'false' failed]`);
});
test('appends stdout and stderr', async () => {
    expect.assertions(1);
    return expect(exec_promise_1.default('echo', ['foo', '&&', '>&2', 'echo', '"this error"', '&&', 'false'])).rejects.toMatchInlineSnapshot(`
[Error: Running command 'echo' failed

foo


this error
]
`);
});
test('prints stderr when exec exits without a code', async () => {
    jest.spyOn(console, 'log').mockImplementation();
    await exec_promise_1.default('>&2 echo "this error"');
    return expect(console.log).toHaveBeenCalledWith('this error\n');
});
//# sourceMappingURL=exec-promise.test.js.map