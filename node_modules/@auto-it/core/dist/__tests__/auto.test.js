"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const auto_1 = tslib_1.__importDefault(require("../auto"));
const semver_1 = tslib_1.__importDefault(require("../semver"));
const logger_1 = require("../utils/logger");
const make_commit_from_msg_1 = tslib_1.__importDefault(require("./make-commit-from-msg"));
const importMock = jest.fn();
jest.mock('import-cwd', () => (path) => importMock(path));
jest.mock('env-ci', () => () => ({ isCi: false, branch: 'master' }));
const defaults = {
    owner: 'foo',
    repo: 'bar',
    token: 'XXXX'
};
const labels = {
    major: 'Version: Major',
    patch: 'Version: Patch',
    minor: 'Version: Minor'
};
const search = jest.fn();
jest.mock('cosmiconfig', () => () => ({
    search
}));
jest.mock('@octokit/rest', () => {
    var _a;
    const instance = (_a = class MockOctokit {
            constructor() {
                this.authenticate = () => undefined;
                this.search = {
                    issuesAndPullRequests: () => ({ data: { items: [] } })
                };
                this.hook = {
                    error: () => undefined
                };
            }
        },
        _a.plugin = () => instance,
        _a);
    return instance;
});
// @ts-ignore
jest.mock('gitlog', () => (a, cb) => {
    cb(undefined, [
        {
            rawBody: 'foo'
        },
        {
            rawBody: 'foo'
        }
    ]);
});
describe('Auto', () => {
    test('should use args', async () => {
        const auto = new auto_1.default(defaults);
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect(auto.release).toBeDefined();
    });
    test('should load config', async () => {
        search.mockReturnValueOnce({ config: defaults });
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect(auto.release).toBeDefined();
    });
    test('should throw if now GH_TOKEN set', async () => {
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        process.env.GH_TOKEN = undefined;
        await expect(auto.loadConfig()).rejects.toBeInstanceOf(Error);
    });
    test('should extend config', async () => {
        search.mockReturnValueOnce({ config: Object.assign(Object.assign({}, defaults), { extends: '@artsy' }) });
        importMock.mockImplementation(path => path === '@artsy/auto-config/package.json'
            ? { auto: { onlyPublishWithReleaseLabel: true } }
            : undefined);
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect(auto.release.options).toMatchSnapshot();
    });
    test('should extend local config', async () => {
        const orig = process.cwd;
        process.cwd = () => '/foo/';
        search.mockReturnValueOnce({
            config: Object.assign(Object.assign({}, defaults), { extends: './fake.json' })
        });
        importMock.mockImplementation(path => path === '/foo/fake.json' ? { bar: 'foo' } : undefined);
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect(auto.release.options).toMatchSnapshot();
        process.cwd = orig;
    });
    test('should use labels from config config', async () => {
        search.mockReturnValueOnce({
            config: Object.assign(Object.assign({}, defaults), { labels })
        });
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect([...auto.semVerLabels.values()]).toStrictEqual([
            ['Version: Major'],
            ['Version: Minor'],
            ['Version: Patch'],
            ['skip-release'],
            ['release'],
            ['prerelease']
        ]);
    });
    test('should add extra skip label', async () => {
        search.mockReturnValueOnce({
            config: Object.assign(Object.assign({}, defaults), { labels: {
                    'skip-release': 'NOPE'
                } })
        });
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect(auto.release.options.skipReleaseLabels).toStrictEqual(['NOPE']);
    });
    test('should be able to add label as string', async () => {
        search.mockReturnValueOnce({
            config: Object.assign(Object.assign({}, defaults), { labels: {
                    minor: 'feature'
                } })
        });
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect(auto.release.options.labels.minor).toStrictEqual([
            {
                description: 'Increment the minor version when merged',
                name: 'feature',
                title: 'ðŸš€  Enhancement'
            }
        ]);
    });
    test('should be able to omit properties from label definition', async () => {
        search.mockReturnValueOnce({
            config: Object.assign(Object.assign({}, defaults), { labels: {
                    minor: {
                        description: 'This is a test'
                    }
                } })
        });
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect(auto.release.options.labels.minor).toStrictEqual([
            {
                description: 'This is a test',
                name: 'minor',
                title: 'ðŸš€  Enhancement'
            }
        ]);
    });
    test('arbitrary labels should be able to omit name', async () => {
        search.mockReturnValueOnce({
            config: Object.assign(Object.assign({}, defaults), { labels: {
                    fooBar: {
                        description: 'This is a test'
                    }
                } })
        });
        const auto = new auto_1.default();
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        expect(auto.release.options.labels.fooBar).toStrictEqual([
            {
                description: 'This is a test',
                name: 'fooBar'
            }
        ]);
    });
    describe('createLabels', () => {
        test('should throw when not initialized', async () => {
            search.mockReturnValueOnce({
                config: Object.assign(Object.assign({}, defaults), { labels })
            });
            const auto = new auto_1.default();
            auto.logger = logger_1.dummyLog();
            await expect(auto.createLabels()).rejects.not.toBeUndefined();
        });
        test('should create the labels', async () => {
            search.mockReturnValueOnce({
                config: Object.assign(Object.assign({}, defaults), { labels })
            });
            const auto = new auto_1.default();
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            jest.spyOn(auto.release, 'addLabelsToProject').mockImplementation();
            await auto.createLabels();
            expect(auto.release.addLabelsToProject).toMatchSnapshot();
        });
    });
    describe('label', () => {
        test('should throw when not initialized', async () => {
            search.mockReturnValueOnce({
                config: Object.assign(Object.assign({}, defaults), { labels })
            });
            const auto = new auto_1.default();
            auto.logger = logger_1.dummyLog();
            await expect(auto.label({ pr: 13 })).rejects.not.toBeUndefined();
        });
        test('should get labels', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const getLabels = jest.fn();
            auto.git.getLabels = getLabels;
            getLabels.mockReturnValueOnce(['foo']);
            jest.spyOn(console, 'log').mockImplementation();
            await auto.label({ pr: 13 });
            expect(console.log).toHaveBeenCalledWith('foo');
        });
        test('should get labels for last merged PR', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const getPullRequests = jest.fn();
            auto.git.getPullRequests = getPullRequests;
            getPullRequests.mockReturnValueOnce([
                {
                    merged_at: '2019-01-08T03:45:33.000Z',
                    labels: [{ name: 'wubbalublub' }]
                },
                {
                    merged_at: '2019-01-10T03:45:33.000Z',
                    labels: [{ name: 'foo' }, { name: 'bar' }]
                }
            ]);
            jest.spyOn(console, 'log').mockImplementation();
            await auto.label();
            expect(console.log).toHaveBeenCalledWith('foo\nbar');
        });
        test('should do nothing when no last merge found', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const getPullRequests = jest.fn();
            auto.git.getPullRequests = getPullRequests;
            getPullRequests.mockReturnValueOnce([]);
            jest
                .spyOn(console, 'log')
                .mockImplementation()
                .mockReset();
            await auto.label();
            expect(console.log).not.toHaveBeenCalled();
        });
    });
    describe('pr', () => {
        let createStatus;
        beforeEach(() => {
            createStatus = jest.fn();
        });
        const required = {
            url: 'https://google.com',
            state: 'pending',
            description: 'foo',
            context: 'bar'
        };
        test('should throw when not initialized', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await expect(auto.prStatus(required)).rejects.not.toBeUndefined();
        });
        test('should catch exceptions when status fails to post', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            createStatus.mockRejectedValueOnce({ status: 400 });
            await expect(auto.prStatus(Object.assign(Object.assign({}, required), { sha: '1234' }))).rejects.toBeInstanceOf(Error);
            expect(createStatus).toHaveBeenCalled();
        });
        test('should do nothing ', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            await auto.prStatus(Object.assign(Object.assign({}, required), { sha: '1234', dryRun: true }));
            expect(createStatus).not.toHaveBeenCalled();
        });
        test('should use provided SHA', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            await auto.prStatus(Object.assign(Object.assign({}, required), { sha: '1234' }));
            expect(createStatus).toHaveBeenCalledWith(expect.objectContaining({
                sha: '1234'
            }));
        });
        test('should use HEAD SHA', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            const getSha = jest.fn();
            auto.git.getSha = getSha;
            getSha.mockReturnValueOnce('abc');
            await auto.prStatus(Object.assign({}, required));
            expect(createStatus).toHaveBeenCalledWith(expect.objectContaining({
                sha: 'abc'
            }));
        });
        test('should use lookup SHA for PR', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            const getPullRequest = jest.fn();
            auto.git.getPullRequest = getPullRequest;
            getPullRequest.mockReturnValueOnce({ data: { head: { sha: 'deep' } } });
            await auto.prStatus(Object.assign(Object.assign({}, required), { pr: 14 }));
            expect(createStatus).toHaveBeenCalledWith(expect.objectContaining({
                sha: 'deep'
            }));
        });
    });
    describe('pr-check', () => {
        jest.setTimeout(10 * 1000);
        let createStatus;
        beforeEach(() => {
            createStatus = jest.fn();
        });
        const required = {
            url: 'https://google.com'
        };
        test('should throw when not initialized', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await expect(auto.prCheck(Object.assign({ pr: 13 }, required))).rejects.not.toBeUndefined();
        });
        test('should do nothing with dryRun', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            await auto.prCheck(Object.assign(Object.assign({}, required), { pr: 13, dryRun: true }));
            expect(createStatus).not.toHaveBeenCalled();
        });
        test('should catch errors', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            await auto.prCheck(Object.assign(Object.assign({}, required), { pr: 13 }));
            expect(createStatus).toHaveBeenCalledWith(expect.objectContaining({
                state: 'error'
            }));
        });
        test('should catch status errors', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            createStatus.mockRejectedValueOnce({ status: 123 });
            await expect(auto.prCheck(Object.assign(Object.assign({}, required), { pr: 13 }))).rejects.toBeInstanceOf(Error);
            expect(createStatus).toHaveBeenCalled();
        });
        test('should error with no label', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            const getPullRequest = jest.fn();
            auto.git.getPullRequest = getPullRequest;
            getPullRequest.mockReturnValueOnce({ data: { head: { sha: 'sha' } } });
            const getLabels = jest.fn();
            auto.git.getLabels = getLabels;
            getLabels.mockReturnValueOnce([]);
            await auto.prCheck(Object.assign(Object.assign({}, required), { pr: 13 }));
            expect(createStatus).toHaveBeenCalledWith(expect.objectContaining({
                description: 'No semver label!'
            }));
        });
        test('should pass with semver label', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            const getPullRequest = jest.fn();
            auto.git.getPullRequest = getPullRequest;
            getPullRequest.mockReturnValueOnce({ data: { head: { sha: 'sha' } } });
            const getLabels = jest.fn();
            auto.git.getLabels = getLabels;
            getLabels.mockReturnValueOnce(['major']);
            await auto.prCheck(Object.assign(Object.assign({}, required), { pr: 13 }));
            expect(createStatus).toHaveBeenCalledWith(expect.objectContaining({
                description: 'CI - major'
            }));
        });
        test('should pass with skip release label', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            const getPullRequest = jest.fn();
            auto.git.getPullRequest = getPullRequest;
            getPullRequest.mockReturnValueOnce({ data: { head: { sha: 'sha' } } });
            const getLabels = jest.fn();
            auto.git.getLabels = getLabels;
            getLabels.mockReturnValueOnce(['major', 'skip-release']);
            await auto.prCheck(Object.assign(Object.assign({}, required), { pr: 13 }));
            expect(createStatus).toHaveBeenCalledWith(expect.objectContaining({
                description: 'PR will not create a release'
            }));
        });
        test('should pass with release label', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            const getPullRequest = jest.fn();
            auto.git.getPullRequest = getPullRequest;
            getPullRequest.mockReturnValueOnce({ data: { head: { sha: 'sha' } } });
            const getLabels = jest.fn();
            auto.git.getLabels = getLabels;
            getLabels.mockReturnValueOnce(['major', 'release']);
            await auto.prCheck(Object.assign(Object.assign({}, required), { pr: 13 }));
            expect(createStatus).toHaveBeenCalledWith(expect.objectContaining({
                description: 'PR will create release once merged - major'
            }));
        });
    });
    describe('comment', () => {
        test('should throw when not initialized', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await expect(auto.comment({ pr: 10, message: 'foo' })).rejects.not.toBeUndefined();
        });
        test('should make a comment', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const createComment = jest.fn();
            auto.git.createComment = createComment;
            await auto.comment({ pr: 10, message: 'foo' });
            expect(createComment).toHaveBeenCalled();
        });
        test('should delete a comment', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const deleteComment = jest.fn();
            auto.git.deleteComment = deleteComment;
            await auto.comment({ pr: 10, delete: true });
            expect(deleteComment).toHaveBeenCalled();
        });
        test('should edit a comment', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const editComment = jest.fn();
            auto.git.editComment = editComment;
            await auto.comment({ pr: 10, message: 'foo', edit: true });
            expect(editComment).toHaveBeenCalled();
        });
        test('should not delete a comment in dry run mode', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const deleteComment = jest.fn();
            auto.git.deleteComment = deleteComment;
            const editComment = jest.fn();
            auto.git.editComment = editComment;
            await auto.comment({ pr: 10, message: 'foo bar', dryRun: true });
            expect(deleteComment).not.toHaveBeenCalled();
            await auto.comment({ pr: 10, delete: true, dryRun: true });
            expect(deleteComment).not.toHaveBeenCalled();
            await auto.comment({
                pr: 10,
                message: 'foo bar',
                edit: true,
                dryRun: true
            });
            expect(deleteComment).not.toHaveBeenCalled();
            expect(editComment).not.toHaveBeenCalled();
        });
    });
    describe('prBody', () => {
        test('should throw when not initialized', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await expect(auto.prBody({ pr: 10, message: 'foo' })).rejects.not.toBeUndefined();
        });
        test('should make a pr body update', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const addToPrBody = jest.fn();
            auto.git.addToPrBody = addToPrBody;
            await auto.prBody({ pr: 10, message: 'foo' });
            expect(addToPrBody).toHaveBeenCalled();
        });
        test('should delete old pr body update', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const addToPrBody = jest.fn();
            auto.git.addToPrBody = addToPrBody;
            await auto.prBody({ pr: 10, delete: true });
            expect(addToPrBody).toHaveBeenCalledWith('', 10, 'default');
        });
        test('should not update pr body a dry run mode', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const addToPrBody = jest.fn();
            auto.git.addToPrBody = addToPrBody;
            await auto.prBody({ pr: 10, message: 'foo bar', dryRun: true });
            expect(addToPrBody).not.toHaveBeenCalled();
            await auto.prBody({ pr: 10, delete: true, dryRun: true });
            expect(addToPrBody).not.toHaveBeenCalled();
        });
    });
    describe('version', () => {
        test('should throw when not initialized', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await expect(auto.version()).rejects.not.toBeUndefined();
        });
        test('should calculate version with default options', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            jest
                .spyOn(auto.git, 'getLatestRelease')
                .mockImplementation(() => Promise.resolve('v1.2.3'));
            jest
                .spyOn(auto.release, 'getSemverBump')
                .mockImplementation(() => Promise.resolve(semver_1.default.patch));
            jest.spyOn(console, 'log').mockImplementation();
            await auto.version();
            expect(auto.release.getSemverBump).toHaveBeenCalledWith('v1.2.3');
            expect(console.log).toHaveBeenCalledWith('patch');
        });
        test('should calculate version with from option', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            jest
                .spyOn(auto.git, 'getLatestRelease')
                .mockImplementation(() => Promise.resolve('v1.2.3'));
            jest
                .spyOn(auto.release, 'getSemverBump')
                .mockImplementation(() => Promise.resolve(semver_1.default.minor));
            jest.spyOn(console, 'log').mockImplementation();
            await auto.version({ from: 'v1.1.0' });
            expect(auto.release.getSemverBump).toHaveBeenCalledWith('v1.1.0');
            expect(console.log).toHaveBeenCalledWith('minor');
        });
    });
    describe('changelog', () => {
        test('should throw when not initialized', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await expect(auto.changelog()).rejects.not.toBeUndefined();
        });
        test('should do nothing on a dryRun', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            const addToChangelog = jest.fn();
            auto.release.addToChangelog = addToChangelog;
            jest.spyOn(auto.release, 'generateReleaseNotes').mockImplementation();
            await auto.changelog({ from: 'v1.0.0', dryRun: true });
            expect(addToChangelog).not.toHaveBeenCalled();
        });
        test('should add to changelog', async () => {
            const auto = new auto_1.default(Object.assign({ plugins: [] }, defaults));
            auto.logger = logger_1.dummyLog();
            auto.hooks.getRepository.tap('test', () => ({ token: '1234' }));
            await auto.loadConfig();
            const addToChangelog = jest.fn();
            auto.release.addToChangelog = addToChangelog;
            jest.spyOn(auto.release, 'generateReleaseNotes').mockImplementation();
            jest.spyOn(auto.release, 'getCommitsInRelease').mockImplementation();
            await auto.changelog({ from: 'v1.0.0' });
            expect(addToChangelog).toHaveBeenCalled();
        });
        test('should skip getRepository hook if passed in via cli', async () => {
            process.env.GH_TOKEN = 'XXXX';
            const auto = new auto_1.default({
                repo: 'test',
                owner: 'adierkens'
            });
            auto.logger = logger_1.dummyLog();
            const hookFn = jest.fn();
            auto.hooks.getRepository.tap('test', hookFn);
            await auto.loadConfig();
            await auto.prStatus({
                url: 'foo.bar',
                state: 'pending',
                description: 'Waiting for stuffs',
                context: 'tests',
                dryRun: true
            });
            expect(hookFn).not.toHaveBeenCalled();
        });
    });
    describe('release', () => {
        test("doesn't try to overwrite releases", async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            jest.spyOn(auto.release, 'generateReleaseNotes').mockImplementation();
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            auto.hooks.getPreviousVersion.tap('test', () => '1.2.3');
            const afterRelease = jest.fn();
            auto.hooks.afterRelease.tap('test', afterRelease);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.runRelease();
            expect(afterRelease).not.toHaveBeenCalled();
        });
        test('should publish with default options', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            jest.spyOn(auto.git, 'publish').mockImplementation();
            jest
                .spyOn(auto.release, 'generateReleaseNotes')
                .mockImplementation(() => Promise.resolve('releaseNotes'));
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            auto.hooks.getPreviousVersion.tap('test', () => '1.2.4');
            const afterRelease = jest.fn();
            auto.hooks.afterRelease.tap('test', afterRelease);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.runRelease();
            expect(auto.release.generateReleaseNotes).toHaveBeenCalledWith('v1.2.3', undefined, undefined);
            expect(auto.git.publish).toHaveBeenCalledWith('releaseNotes', 'v1.2.4');
            expect(afterRelease).toHaveBeenCalledWith(expect.objectContaining({
                lastRelease: 'v1.2.3',
                newVersion: 'v1.2.4'
            }));
        });
        test('should publish with lastRelease using from option', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            jest.spyOn(auto.git, 'publish').mockImplementation();
            jest
                .spyOn(auto.release, 'generateReleaseNotes')
                .mockImplementation(() => Promise.resolve('releaseNotes'));
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            auto.hooks.getPreviousVersion.tap('test', () => '1.2.4');
            const afterRelease = jest.fn();
            auto.hooks.afterRelease.tap('test', afterRelease);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.runRelease({
                from: 'v1.2.0'
            });
            expect(auto.release.generateReleaseNotes).toHaveBeenCalledWith('v1.2.0', undefined, undefined);
            expect(auto.git.publish).toHaveBeenCalledWith('releaseNotes', 'v1.2.4');
            expect(afterRelease).toHaveBeenCalledWith(expect.objectContaining({
                lastRelease: 'v1.2.0',
                newVersion: 'v1.2.4'
            }));
        });
        test('should publish with newVersion using useVersion option', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            jest.spyOn(auto.git, 'publish').mockImplementation();
            jest
                .spyOn(auto.release, 'generateReleaseNotes')
                .mockImplementation(() => Promise.resolve('releaseNotes'));
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            auto.hooks.getPreviousVersion.tap('test', () => '1.2.4');
            const afterRelease = jest.fn();
            auto.hooks.afterRelease.tap('test', afterRelease);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.runRelease({
                useVersion: 'v1.3.0'
            });
            expect(auto.release.generateReleaseNotes).toHaveBeenCalledWith('v1.2.3', undefined, undefined);
            expect(auto.git.publish).toHaveBeenCalledWith('releaseNotes', 'v1.3.0');
            expect(afterRelease).toHaveBeenCalledWith(expect.objectContaining({
                lastRelease: 'v1.2.3',
                newVersion: 'v1.3.0'
            }));
        });
    });
    describe('canary', () => {
        test('should throw when not initialized', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await expect(auto.canary()).rejects.not.toBeUndefined();
        });
        test('does not call canary hook in dry-run', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            const canary = jest.fn();
            auto.hooks.canary.tap('test', canary);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.canary({ pr: 123, build: 1, dryRun: true });
            expect(canary).not.toHaveBeenCalled();
        });
        test('calls the canary hook with the pr info', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            auto.git.getSha = () => Promise.resolve('abc');
            jest.spyOn(auto.git, 'addToPrBody').mockImplementation();
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            const canary = jest.fn();
            auto.hooks.canary.tap('test', canary);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.canary({ pr: 123, build: 1 });
            expect(canary).toHaveBeenCalledWith(semver_1.default.patch, '.123.1');
            expect(auto.git.addToPrBody).toHaveBeenCalled();
        });
        test('falls back to first commit', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestTagInBranch = () => {
                throw new Error();
            };
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            auto.git.getSha = () => Promise.resolve('abc');
            auto.release.getCommits = () => Promise.resolve([]);
            auto.git.getFirstCommit = () => Promise.resolve('abcd');
            jest.spyOn(auto.git, 'addToPrBody').mockImplementation();
            jest
                .spyOn(auto.release, 'getCommitsInRelease')
                .mockImplementation()
                .mockReturnValue(Promise.resolve([make_commit_from_msg_1.default('Test Commit')]));
            const canary = jest.fn();
            auto.hooks.canary.tap('test', canary);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.canary({ pr: 123, build: 1 });
            expect(auto.release.getCommits).toHaveBeenCalledWith('abcd');
        });
        test('adds sha if no pr or build number is found', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            auto.git.getSha = () => Promise.resolve('abc');
            jest.spyOn(auto.git, 'addToPrBody').mockImplementation();
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            const canary = jest.fn();
            auto.hooks.canary.tap('test', canary);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.canary();
            expect(canary).toHaveBeenCalledWith(semver_1.default.patch, '.abc');
        });
        test("doesn't comment if there is an error", async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            jest.spyOn(auto, 'prBody').mockImplementation();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            auto.git.getSha = () => Promise.resolve('abc');
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            const canary = jest.fn();
            canary.mockReturnValue({ error: 'ooops' });
            auto.hooks.canary.tap('test', canary);
            jest.spyOn(auto.release, 'getCommits').mockImplementation();
            await auto.canary({ pr: 123, build: 1 });
            expect(auto.prBody).not.toHaveBeenCalled();
        });
        test('defaults to sha when run locally', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getSha = () => Promise.resolve('abcd');
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default('Test Commit')]);
            const canary = jest.fn();
            auto.hooks.canary.tap('test', canary);
            await auto.canary();
            expect(canary).toHaveBeenCalledWith(semver_1.default.patch, '.abcd');
        });
        test('works when PR has "skip-release" label', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getSha = () => Promise.resolve('abcd');
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            auto.release.getCommitsInRelease = () => Promise.resolve([
                make_commit_from_msg_1.default('Test Commit', {
                    labels: ['skip-release']
                })
            ]);
            const canary = jest.fn();
            auto.hooks.canary.tap('test', canary);
            await auto.canary();
            expect(canary).toHaveBeenCalledWith(semver_1.default.patch, '.abcd');
        });
    });
    describe('shipit', () => {
        test('should throw when not initialized', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            await expect(auto.shipit()).rejects.not.toBeUndefined();
        });
        test('should not publish when no latest version found', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('');
            auto.release.getSemverBump = () => Promise.resolve(semver_1.default.noVersion);
            const afterShipIt = jest.fn();
            auto.hooks.afterShipIt.tap('test', afterShipIt);
            await auto.shipit();
            expect(afterShipIt).not.toHaveBeenCalled();
        });
        test('should publish to latest on base branch', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            jest.spyOn(auto.git, 'publish').mockImplementation();
            jest.spyOn(auto.release, 'getCommitsInRelease').mockImplementation();
            jest.spyOn(auto.release, 'generateReleaseNotes').mockImplementation();
            jest.spyOn(auto.release, 'addToChangelog').mockImplementation();
            const afterShipIt = jest.fn();
            auto.hooks.afterShipIt.tap('test', afterShipIt);
            await auto.shipit();
            expect(afterShipIt).toHaveBeenCalled();
        });
        test('should skip publish in dry run', async () => {
            const auto = new auto_1.default(Object.assign(Object.assign({}, defaults), { plugins: [] }));
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.getLatestRelease = () => Promise.resolve('1.2.3');
            jest.spyOn(auto.git, 'publish').mockImplementation();
            jest.spyOn(auto.release, 'getCommitsInRelease').mockImplementation();
            jest.spyOn(auto.release, 'generateReleaseNotes').mockImplementation();
            jest.spyOn(auto.release, 'addToChangelog').mockImplementation();
            const version = jest.fn();
            auto.hooks.version.tap('test', version);
            await auto.shipit({ dryRun: true });
            expect(version).not.toHaveBeenCalled();
        });
    });
});
describe('hooks', () => {
    test('should be able to modifyConfig', async () => {
        const auto = new auto_1.default(defaults);
        auto.logger = logger_1.dummyLog();
        auto.hooks.modifyConfig.tap('test', testConfig => {
            testConfig.labels.released = [
                {
                    name: 'released',
                    description: 'This issue/pull request has been released'
                }
            ];
            return testConfig;
        });
        await auto.loadConfig();
        expect(auto.labels.released).toStrictEqual([
            {
                description: 'This issue/pull request has been released',
                name: 'released'
            }
        ]);
    });
    describe('logParse', () => {
        test('should be able to tap parseCommit', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            auto.hooks.onCreateLogParse.tap('test', logParse => {
                logParse.hooks.parseCommit.tap('test parse', commit => {
                    commit.labels = [...auto.semVerLabels.get(semver_1.default.major)];
                    return commit;
                });
            });
            await auto.loadConfig();
            auto.git.getLatestRelease = async () => Promise.resolve('1.0.0');
            jest.spyOn(console, 'log').mockImplementation();
            await auto.version();
            expect(console.log).toHaveBeenCalledWith('major');
        });
        test('should be able to tap omitCommit', async () => {
            const auto = new auto_1.default(defaults);
            auto.logger = logger_1.dummyLog();
            auto.hooks.onCreateLogParse.tap('test', logParse => {
                logParse.hooks.parseCommit.tap('test parse', commit => {
                    commit.labels = [...auto.semVerLabels.get(semver_1.default.major)];
                    return commit;
                });
            });
            auto.hooks.onCreateLogParse.tap('test', logParse => {
                logParse.hooks.omitCommit.tap('test omit', commit => {
                    if (commit.labels.includes('major')) {
                        return true;
                    }
                });
            });
            await auto.loadConfig();
            auto.git.getLatestRelease = async () => Promise.resolve('1.0.0');
            jest.spyOn(console, 'log').mockImplementation();
            await auto.version();
            expect(console.log).toHaveBeenCalledWith('patch');
        });
    });
});
//# sourceMappingURL=auto.test.js.map